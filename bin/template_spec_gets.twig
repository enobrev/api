<?php
    namespace {{ spec.namespace.spec }}\{{ table.name }};

    use Adbar\Dot;
    use Psr\Http\Message\ResponseInterface;
    use Psr\Http\Message\ServerRequestInterface;
    use Psr\Http\Server\MiddlewareInterface;
    use Psr\Http\Server\RequestHandlerInterface;

    use Enobrev\API\DataMap;
    use Enobrev\API\FullSpec;
    use Enobrev\API\FullSpecComponent as FSC;
    use Enobrev\API\HTTP;
    use Enobrev\API\Method;
    use Enobrev\API\Middleware\FastRoute;
    use Enobrev\API\Middleware\ResponseBuilder;
    use Enobrev\API\Param;
    use Enobrev\API\Spec;
    use Enobrev\API\SpecInterface;

    use {{ spec.namespace.table }};

    class {{ spec.name }} implements SpecInterface, MiddlewareInterface {
        public function spec(): Spec {
            return Spec::create()
                ->httpMethod      (Method\{{ spec.http_method }})
                ->path            ('{{ spec.path_prefix}}/{{ table.name }}[/]')
                ->summary         ('List {{ table.name }}')
                ->description     ('Get listing of `{{ table.name }}`')
                ->scopes          ({{ spec.scopes|raw }})
                ->tag             ('{{ table.name }}')
                ->queryParams     ([
                    'page'     => new Param\_Integer('page',   0, ['default' => 1],    "Current Page of `{{ table.name }}`"),
                    'per'      => new Param\_Integer('per',    0, ['default' => 100],  "Number of `{{ table.name }}` per page of Data"),
                    'search'   => new Param\_String( 'search', 0, ['default' => null], "Search term.  Can be a plain string or in the format field:value"),
                    'sort'     => new Param\_String( 'sort',   0, ['default' => null], "`{{ table.name }}` field to sort by"){% if has_date %},{% endif %}

{% if has_date %}
                    'sync'     => new Param\_String( 'sync',   0, ['default' => null], "Get only `{{ table.name }}` with an updated date since the date in `sync`")
{% endif %}
                ])
                ->response(HTTP\OK,                    FSC::ref(components::RESPONSE_SUCCESS))
                ->response(HTTP\BAD_REQUEST,           FSC::ref(FullSpec::RESPONSE_BAD_REQUEST))           // See _request.validation
                ->response(HTTP\UNAUTHORIZED,          FSC::ref(FullSpec::RESPONSE_UNAUTHORIZED))          // Client Should Re-Auth
                ->response(HTTP\FORBIDDEN,             FSC::ref(FullSpec::RESPONSE_FORBIDDEN))             // Authed Client Not Allowed Access
                ->response(HTTP\UNPROCESSABLE_ENTITY,  FSC::ref(FullSpec::RESPONSE_UNPROCESSABLE_ENTITY))  // See _request.errors
                ->response(HTTP\INTERNAL_SERVER_ERROR, FSC::ref(FullSpec::RESPONSE_SERVER_ERROR));         // See _server.errors
        }

        /**
         * @param array|null $aPathParams   Params from Request Path
         * @param array|null $aQueryParams  Params from Request Query
         * @param array|null $aPostParams   Params from Request Body
         * @param Dot $oResponse            Response Object
         * @return Dot
         */
        protected function getResponse(?array $aPathParams, ?array $aQueryParams, ?array $aPostParams, Dot $oResponse): Dot {
            $oBaseTable = new {{ table.class }};
            $aSearch    = DataMap::convertSearchTablesToORMTables($oBaseTable, $aQueryParams['search']);
            $aSort      = DataMap::convertSortTablesToORMTables($oBaseTable,   $aQueryParams['sort']);

            /** @var {{ table.class }}[] $a{{ table.plural }} */
            $a{{ table.plural }} = {{ table.class_plural }}::getForCMS(
                $aQueryParams['page'],
                $aQueryParams['per'],
                $aSearch,
                $aSort{% if has_date %},
                $aQueryParams['sync']
{% endif %}
            );

            foreach($a{{ table.plural }} as $o{{ table.title }}) {
{% if primary|length > 1 %}
                $oResponse->set("{{ table.name }}.{% for field in primary %}{{ '{' }}$o{{ table.title }}->{{ field.name }}->getValue(){{ '}' }}{% if not loop.last %}-{% endif %}{% endfor %}", DataMap::convertTableToResponseArray($o{{ table.title }}));
                $oResponse->push("sorts.{{ table.name }}", "{% for field in primary %}{{ '{' }}$o{{ table.title }}->{{ field.name }}->getValue(){{ '}' }}{% if not loop.last %}-{% endif %}{% endfor %}");
{% else %}
                $oResponse->set("{{ table.name }}.{$o{{ table.title }}->{{ primary.0.name }}->getValue()}", DataMap::convertTableToResponseArray($o{{ table.title }}));
                $oResponse->push('sorts.{{ table.name }}', $o{{ table.title }}->{{ primary.0.name }}->getValue());
{% endif %}
            }

            $oResponse->set('counts.{{ table.name }}', {{ table.class_plural }}::countForCMS());

            return $oResponse;
        }

        /**
         * Middleware
         * Use the ServerRequestInterface to figure out what is needed
         * Either return a ResponseInterface (and stop processing other Middleware)
         *     or return a call to Handler::handle (and allow other Middleware to continue processing)
         * The ResponseBuilder data should match the Schema defined in spec();

         * @param ServerRequestInterface $oRequest
         * @param RequestHandlerInterface $oHandler
         * @return ResponseInterface
         */
        public function process(ServerRequestInterface $oRequest, RequestHandlerInterface $oHandler): ResponseInterface {
            return $oHandler->handle(
                ResponseBuilder::update($oRequest,
                    $this->getResponse(
                        FastRoute::getPathParams($oRequest),
                        $oRequest->getQueryParams(),
                        $oRequest->getParsedBody(),
                        ResponseBuilder::get($oRequest)
                    )
                )
            );
        }
    }