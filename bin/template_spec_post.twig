<?php
    namespace {{ spec.namespace.spec }}\{{ table.name }};

    use Adbar\Dot;
    use Psr\Http\Message\ResponseInterface;
    use Psr\Http\Message\ServerRequestInterface;
    use Psr\Http\Server\MiddlewareInterface;
    use Psr\Http\Server\RequestHandlerInterface;

    use Enobrev\API\Method;
    use Enobrev\API\Middleware\FastRoute;
    use Enobrev\API\Middleware\ResponseBuilder;
    use Enobrev\API\Param;
    use Enobrev\API\Spec;
    use Enobrev\API\SpecInterface;

    use {{ spec.namespace.table }};

    class {{ spec.name }} implements SpecInterface, MiddlewareInterface {
        public function spec(): Spec {
            return Spec::create()
                ->httpMethod      (Method\{{ spec.http_method }})
                ->path            ('{{ spec.path_prefix}}/{{ table.name }}/{% for field in primary %}{{ '{' }}{{ field.short }}{{ '}' }}{% if not loop.last %}-{% endif %}{% endfor %}')
                ->summary         ('Create or Update `{{ table.name }}`')
                ->description     ('Create or Update `{{ table.name }}` designated by {% for field in primary%}{% if loop.first %}{% elseif loop.last %} and {% else %}, {% endif %}`{{ field.short }}`{% endfor %}')
                ->scopes          ({{ spec.scopes|raw }})
                ->tag             ('{{ table.name }}')
                ->postParams      (Spec::tableToParams(new {{ table.class }}, Spec::SKIP_PRIMARY))
                ->pathParams      ([
{% for field in fields %}
{% if field.primary %}
                    '{{ field.short }}'{{ field.short_pad }}=> new Param\{{ field.param_class }}('{{ field.short }}',{{ field.short_pad }}Param::REQUIRED){% if not loop.last %},{% endif %}

{% endif %}
{% endfor %}
                ])
                ->responseSchema  ([
                    'type' => 'object',
                    'properties' => [
                        '{{ table.name }}' => [
                            'type' => 'object',
                            'properties' => [
                                '{% for field in primary %}{{ '{' }}{{ field.short }}{{ '}' }}{% if not loop.last %}-{% endif %}{% endfor %}' => [
                                    'type' => 'object',
                                    'properties' => Spec::tableToJsonSchema(new {{ table.class }})
                                ]
                            ]
                        ]
                    ]
                ]);
        }

        /**
         * @param array|null $aPathParams   Params from Request Path
         * @param array|null $aQueryParams  Params from Request Query
         * @param array|null $aPostParams   Params from Request Body
         * @param Dot $oResponse            Response Object
         * @return Dot
         */
        protected function getResponse(?array $aPathParams, ?array $aQueryParams, ?array $aPostParams, Dot $oResponse): Dot {
            $o{{ table.title }} = {{ table.class }}::getById({% for field in primary %}$aPathParams['{{ field.short }}']{% if not loop.last %}, {% endif %}{% endfor %});
            if ($o{{ table.title }} instanceof {{ table.class }} === false) {
                $o{{ table.title }} = new {{ table.class }};
{% for field in primary %}
                $o{{ table.title }}->{{ field.name }}->setValue($aPathParams['{{ field.short }}']);
{% endfor %}
                $o{{ table.title }}->setFromArray($aPostParams);
                $o{{ table.title }}->insert();
            } else {
                $o{{ table.title }}->setFromArray($aPostParams);
                $o{{ table.title }}->update();
            }

            return $oResponse;
        }

        /**
         * Middleware
         * Use the ServerRequestInterface to figure out what is needed
         * Either return a ResponseInterface (and stop processing other Middleware)
         *     or return a call to Handler::handle (and allow other Middleware to continue processing)
         * The ResponseBuilder data should match the Schema defined in spec();

         * @param ServerRequestInterface $oRequest
         * @param RequestHandlerInterface $oHandler
         * @return ResponseInterface
         */
        public function process(ServerRequestInterface $oRequest, RequestHandlerInterface $oHandler): ResponseInterface {
            $oRequest = ResponseBuilder::update($oRequest,
                $this->getResponse(
                    FastRoute::getPathParams($oRequest),
                    $oRequest->getQueryParams(),
                    $oRequest->getParsedBody(),
                    ResponseBuilder::get($oRequest)
                )
            );

            return (new get())->process($oRequest, $oHandler);
        }
    }